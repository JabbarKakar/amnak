import 'dart:async';

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:amnak/core/view/widgets/language_direction.dart';
import 'package:amnak/export.dart';
import 'package:amnak/features/walki/models/walkie_talkie_models.dart';
import 'package:amnak/features/walki/provider/walkie_talkie_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';

class WalkiPage extends StatefulWidget {
  const WalkiPage({super.key, required this.channel, required this.token});
  final String token;
  final String channel;

  @override
  State<WalkiPage> createState() => _WalkiPageState();
}

// Application state class
class _WalkiPageState extends State<WalkiPage> {
  late RtcEngine _engine;
  bool _isSpeaking = false;
  bool _isConnected = false;
  List<int> _remoteUsers = [];
  Timer? _messageTimer;

  @override
  void initState() {
    super.initState();
    initAgora();
    _startMessageTimer();
  }

  void _startMessageTimer() {
    // Send a message every 30 seconds to keep the connection alive
    _messageTimer = Timer.periodic(const Duration(seconds: 30), (timer) {
      if (_isConnected) {
        _sendKeepAliveMessage();
      }
    });
  }

  Future<void> _sendKeepAliveMessage() async {
    final provider = context.read<WalkieTalkieProvider>();

    // Send a keep-alive message
    await provider.sendWalkieTalkieMessage({
      'voice_group_id': '1', // Default voice group
      'channel_name': widget.channel,
      'sender_id': 37, // This should come from user data
      'sender_type': 'App\\Models\\Person',
      'receiver_id': '36', // This should be dynamic
      'receiver_type': 'App\\Models\\Person',
      'message': 'Keep alive message',
      'audio_path': '', // No audio for keep alive
    });
  }

  // Initialize
  Future<void> initAgora() async {
    Logger().i('Channel: ${widget.channel}');
    Logger().i('Token: ${widget.token}');

    // Get permission
    await [Permission.microphone].request();

    // Create an RtcEngine instance
    _engine = await createAgoraRtcEngine();

    // Initialize RtcEngine and set the channel profile
    await _engine.initialize(const RtcEngineContext(
      appId: appId,
      channelProfile: ChannelProfileType.channelProfileCommunication,
    ));

    // Handle engine events
    _engine.registerEventHandler(
      RtcEngineEventHandler(
        onJoinChannelSuccess: (RtcConnection connection, int elapsed) {
          Logger().i('local user ${connection.localUid} joined');
          setState(() {
            _isConnected = true;
          });
        },
        onError: (err, msg) {
          Logger().e('onError: $err, $msg');
          setState(() {
            _isConnected = false;
          });
        },
        onUserJoined:
            (RtcConnection connection, int remoteUid, int elapsed) async {
          Logger().i("remote user $remoteUid joined");
          setState(() {
            _remoteUsers.add(remoteUid);
          });
          await _engine.setEnableSpeakerphone(true);
          await _engine.muteLocalAudioStream(true);
        },
        onUserOffline: (RtcConnection connection, int remoteUid,
            UserOfflineReasonType reason) {
          Logger().i("remote user $remoteUid left channel");
          setState(() {
            _remoteUsers.remove(remoteUid);
          });
        },
        onAudioVolumeIndication: (RtcConnection connection,
            List<AudioVolumeInfo> speakers,
            int speakerNumber,
            int totalVolume) {
          // Handle audio volume indication
          for (var speaker in speakers) {
            if (speaker.uid == 0) {
              // Local user
              if ((speaker.volume ?? 0) > 0) {
                setState(() {
                  _isSpeaking = true;
                });
              }
            }
          }
        },
      ),
    );

    // Join a channel using a temporary token and channel name
    await _engine.joinChannel(
      token: widget.token,
      channelId: widget.channel,
      options: const ChannelMediaOptions(
        // Automatically subscribe to all audio streams
        autoSubscribeAudio: true,
        // Publish microphone audio
        publishMicrophoneTrack: true,
        // Set user role to clientRoleBroadcaster (broadcaster) or clientRoleAudience (audience)
        clientRoleType: ClientRoleType.clientRoleBroadcaster,
      ),
      uid:
          0, // When you set uid to 0, a user name is randomly generated by the engine
    );
  }

  @override
  void dispose() {
    super.dispose();
    _messageTimer?.cancel();
    _dispose();
  }

  Future<void> _dispose() async {
    await _engine.leaveChannel(); // Leave the channel
    await _engine.release(); // Release resources
  }

  Future<void> _muteMic() async {
    await _engine.muteLocalAudioStream(true);
    setState(() => _isSpeaking = false);
  }

  Future<void> _unmuteMic() async {
    await _engine.muteLocalAudioStream(false);
    setState(() => _isSpeaking = true);
  }

  @override
  Widget build(BuildContext context) {
    return LanguageDirection(
      child: Scaffold(
        appBar: AppBar(
          title: Text(
            'Walkie Talkie - ${widget.channel}',
            style: context.textTheme.titleLarge?.copyWith(
              color: Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
          backgroundColor: kPrimaryColor,
          elevation: 0,
          iconTheme: const IconThemeData(color: Colors.white),
        ),
        body: Column(
          children: [
            // Connection Status
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(16),
              color: _isConnected
                  ? Colors.green.withOpacity(0.1)
                  : Colors.red.withOpacity(0.1),
              child: Row(
                children: [
                  Icon(
                    _isConnected ? Icons.wifi : Icons.wifi_off,
                    color: _isConnected ? Colors.green : Colors.red,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    _isConnected ? 'Connected' : 'Disconnected',
                    style: context.textTheme.titleMedium?.copyWith(
                      color: _isConnected ? Colors.green : Colors.red,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const Spacer(),
                  Text(
                    '${_remoteUsers.length} users online',
                    style: context.textTheme.bodyMedium?.copyWith(
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ),
            ),

            // Main Content
            Expanded(
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // Microphone Button
                    GestureDetector(
                      onTapDown: (_) => _unmuteMic(),
                      onTapUp: (_) => _muteMic(),
                      onTapCancel: () => _muteMic(),
                      child: Container(
                        width: 120,
                        height: 120,
                        decoration: BoxDecoration(
                          color: _isSpeaking
                              ? Colors.redAccent
                              : Colors.blueAccent,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: (_isSpeaking
                                      ? Colors.redAccent
                                      : Colors.blueAccent)
                                  .withOpacity(0.3),
                              blurRadius: 20,
                              spreadRadius: 5,
                            ),
                          ],
                        ),
                        child: Icon(
                          _isSpeaking ? Icons.mic : Icons.mic_off,
                          color: Colors.white,
                          size: 50,
                        ),
                      ),
                    ),

                    const SizedBox(height: 24),

                    // Status Text
                    Text(
                      _isSpeaking ? 'Speaking...' : 'Hold to speak',
                      style: context.textTheme.titleLarge?.copyWith(
                        color:
                            _isSpeaking ? Colors.redAccent : Colors.grey[600],
                        fontWeight: FontWeight.w500,
                      ),
                    ),

                    const SizedBox(height: 16),

                    // Channel Info
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 16, vertical: 8),
                      decoration: BoxDecoration(
                        color: kPrimaryColor.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(20),
                      ),
                      child: Text(
                        'Channel: ${widget.channel}',
                        style: context.textTheme.bodyMedium?.copyWith(
                          color: kPrimaryColor,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),

            // Message Status
            Consumer<WalkieTalkieProvider>(
              builder: (context, provider, child) {
                if (provider.isLoadingMessage) {
                  return Container(
                    padding: const EdgeInsets.all(16),
                    child: const Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        ),
                        SizedBox(width: 8),
                        Text('Sending message...'),
                      ],
                    ),
                  );
                }

                if (provider.errorMessageSend != null) {
                  return Container(
                    padding: const EdgeInsets.all(16),
                    color: Colors.red.withOpacity(0.1),
                    child: Row(
                      children: [
                        const Icon(Icons.error, color: Colors.red, size: 16),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            provider.errorMessageSend!,
                            style: const TextStyle(color: Colors.red),
                          ),
                        ),
                        IconButton(
                          onPressed: provider.clearMessageError,
                          icon: const Icon(Icons.close,
                              color: Colors.red, size: 16),
                        ),
                      ],
                    ),
                  );
                }

                return const SizedBox.shrink();
              },
            ),
          ],
        ),
      ),
    );
  }
}
